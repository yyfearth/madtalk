// Generated by eXtraCoffeeScript 1.2.0r
(function() {
"use strict";
  var app, channel, channels, express, id, io, port;

  express = require('express');

  app = express.createServer();

  io = require('socket.io').listen(app);

  io.set('transports', ['websocket', 'flashsocket']);

  port = 8008;

  app.configure(function() {
    app.use(express["static"](__dirname + '/client'));
    app.set('view engine', 'coffee');
    return app.register('.coffee', require('coffeekup').adapters.express);
  });

  app.get('/', function(req, res) {
    var id;
    console.log('A client has requested this route.');
    id = 0;
    return res.redirect('/' + id);
  });

  app.get(/^\/[\w\-]+\/?$/, function(req, res) {
    return res.render('index');
  });

  channels = [];

  channels.index = {};

  id = 0;

  channel = io.of('/' + id);

  channel.records = [];

  channel.users = [];

  channel.users.index = {};

  channel.ts = new Date().getTime();

  channel.on('connection', function(socket) {
    console.log('a user conn, wait for login ...', socket.id);
    return socket.on('login', function(user, callback) {
      var u;
      if (!(user != null ? user.nick : void 0)) {
        return callback({
          err: 'invalid user'
        });
      }
      if (user.id && ((u = channel.users.index[id]) != null)) {
        delete channel.users.index[id];
        if (u.nick !== user.nick) u.nick = user.nick;
        u.uid = socket.id;
        user = u;
      } else if (user.nick && ((u = channel.users.index[user.nick]) != null)) {
        if (u.status !== 'offline') {
          return callback({
            err: 'dup nick'
          });
        }
        u.uid = socket.id;
        user = u;
      } else {
        user.uid = socket.id;
        channel.users.push(user);
      }
      channel.users.index[user.nick] = channel.users.index[user.uid] = user;
      user.status = 'online';
      socket.broadcast.emit('online', user);
      socket.on('message', function(data, callback) {
        data.user = user;
        data.ts = new Date().getTime();
        console.log(data);
        channel.emit('message', data);
        channel.records.push(data);
        return callback(true);
      });
      socket.on('disconnect', function() {
        user.status = 'offline';
        return socket.broadcast.emit('offline', user);
      });
      return callback(user, {
        records: channel.records,
        users: channel.users,
        ts: channel.ts
      });
    });
  });

  app.listen(port);

  console.log("app listening on port " + port + " ...");

}).call(this);
